<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Edith Llontrop, Stefanie Gschwind, CS184-??</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>"Triangles are rasterized by How we rasterized triangles"</p>

<p>In order to rasterize triangles we take the three points given to us create the smallest enclosing square to the triangle by indicating what the smallest and largest
  x value is; we do the same for the y axis. We make sure that after finding these values to floor them so that we can deal with integers rather than decimals.
  Once this is done we go through each pixel in our smallest enclosing box and initialize a new variable z that takes into consideration 
  how many samples we have for this  pixel. Here however, z=1 as we are not supersampling, thus we make sure to find out new_x and new_y point that are 0.5 away from the original
  pixel coordinate, denoting the center. After getting this new point we pass it into a function we created outselves called inside_line() that returns a value if the pixel is in
  the three lines that make up the triangle. The inside_line() function uses the equation we have seen in class. In order to do this we make sure that the values returned from inside_line() are all greater 
  than or equal to 0. In which we would proceed to update the sample_buffer to include the correct color for this pixel. 

  Our algorithm is no worse than one that checks each sample within the bounding box of the triangle because we still check each pixel 
  inside of the minimium enclosing square that we created.

</p>

<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/image1.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image2.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/image3.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image4.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>


<p>Our supersampling algorithm functions with modifications of our original triangle rasterization algorithm, the resolve_to_framebuffer() function, the set_sample_rate() function, and the fill_pixel() function.
   In rasterize triangle we introduce a new variable z that keeps track of which number supersample we are currently taking inside one pixel. We also add two nested for loops that loop for varables i,j in the range of 0 to the square root 
  of our sample size. This helps us find the exact float (position inside the pixel) that we need to be sampling from. The x, y positions of the supersample locations are computed by the equation: 
  supersample x/y location = integar x/y pixel location + (i/j + 0.5)/(square root of sample rate). Where i,j are the same variables mentioned earlier and correspond to x,y respectivley. We check if each supersample exists inside the triangle using the
three line test. If the spersample does lie within the triangle then we assign sample_buffer[z*(width*height)+(y*width+x)]=color. In order for this indexing to work, we increased the size of the sample buffer from width*height to sample_rate*width*height 
the set_sample_rate() function. Eventhough the samplebuffer is just a (sample_rate * width * height) long one dimensional array, we imagined it as sample_rate many (width*height) long arrays. Thus the different supersamples were stored at the index locations
z*(width*height)+(y*width+x), where z*(width*height) offsets all z consecutive supersamples from the previous supersample by width*height. This implementation however, caused the black boarder lines of the images to become blurred and transparent, thus we had 
to make changes to fill_pixel(). Since our implementation of rasterize_triangle() doesn't call fill_pixel(), we know that fill_pixel() is only called by rasterize_point() and rasterize_line() and in both of those cases we know that what we are rasterizing is necessarily 
occupying the entire pixel area with the given color. Thus we add a for loop in fill_pixel() that assigns the desired color for all z locations in the resized sample_buffer that correspond to that pixel's supersamples. This had to be done since our supersample implementation
modified resolve_to_framebuffer() to average the colors of all z supersamples before assigning it to the framebuffer.</p>

<p>Supersampling is useful because not all shapes and lines occupy all pixels completely. When we make the assumption that a pixel is either 100% in the shape or 0% in the shape, we end up with really pronounced jaggies. By supersampling we get a rough esitmation of
  what percent of a certain pixel is inside a given geometric object. Then we can use that percentage to compute a modified color value for that pixel. The more supersamples in a pixel that test as inside an object, the closer that pixel color is to being the same color as a pixel
  which is entirely in the given shape. Supersampling acts almost as a sort of gradient effect for the edges of objects as the colors of the edge pixels will more gradually tarnsition from object color to background color. This reduces the visibility/presence of jaggies. Another way to think of supersampling
  is as an increase in the sample rate. When we supersample, we're sampling an extra z amount of times per pixel in different locations. That is, we're considering more samples and thus atialiasing our triangles.
</p>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/screenshot_2-13_22-25-49.png" align="middle" width="400px"/>
        <figcaption align="middle"> basic/test4.svg with sample rate = 1</figcaption>
      </td>
      <td>
        <img src="images/screenshot_2-13_22-25-51.png" align="middle" width="400px"/>
        <figcaption align="middle">basic/test4.svg with sample rate = 4</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/screenshot_2-13_22-25-55.png" align="middle" width="400px"/>
        <figcaption align="middle">basic/test4.svg with sample rate = 16</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>These results are observed since as we increase our sampling rate, we're sampling in more locations within one pixel. When we have more spread out samples throughout the pixel we are able to catch cases of only a subpart of a pixel being within the triangle
  more freqently. </p>

<h3 align="middle">Part 3: Transforms</h3>
<p> We tried getting the cubeman to seem as if it was running to give you a hug. We changed some of the colors of its body to reflect Valentine's Day colors. </p>
  
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/cubeman.png" align="middle" width="400px"/>
        <figcaption align="middle"> basic/test7.svg with sample rate = 1</figcaption>
      </td>
    </tr>
  </table>
</div>



<h2 align="middle">Section II: Sampling</h2>


<h3 align="middle">Part 4: Barycentric coordinates</h3>

<p> 
  A Barycentric coordinate is a way to define a point (x,y) with respect to the three sides of a triangle. Lets define the three vertex points of a triangle as A, B, and C. Alpha is defined as the distance between point (x,y) and the line created by the two vertices B, C divided
  by the distance betwee vertex A and the line created by vertices B, C. Beta is defined as the distance between point (x,y) and the line created by the two vertices C,A divided
  by the distance betwee vertex B and the line created by vertices C, A. Gamma is defined as the distance between point (x,y) and the line created by the two vertices A, B divided
  by the distance betwee vertex C and the line created by vertices A, B. Another way to think about alpha, beta, and gamma is as the proportional distances of (x,y) to each of the three vertices. If 0 &le; alpha, beta, gamma &le; 1 and
  alpha + beta + gamma = 1, then we know that (x,y) is inside the triangle defined by the vertices A,B,C.
</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/screenshot_2-13_23-34-20.png" align="middle" width="400px"/>
        <figcaption align="middle"> basic/test7.svg with sample rate = 1</figcaption>
      </td>
    </tr>
  </table>
</div>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
